{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["import * as utils from '@iobroker/adapter-core';\nimport fs from 'fs';\n\ninterface GetNotificationsResponse {\n    result: NotificationsObject;\n}\n\ninterface NotificationsObject {\n    [scope: string]: {\n        /** i18n description of scope */\n        description: Record<string, string>;\n        /** i18n name of scope */\n        name: Record<string, string>;\n        categories: {\n            [category: string]: {\n                instances: {\n                    [adapterInstance: string]: {\n                        messages: NotificationInstanceMessage[];\n                    };\n                };\n                /** i18n description of category */\n                description: Record<string, string>;\n                /** i18n name of category */\n                name: Record<string, string>;\n                severity: 'alert' | 'info' | 'notify';\n            };\n        };\n    };\n}\n\ninterface NotificationInstanceMessage {\n    message: string;\n    ts: number;\n}\n\ninterface SendNotificationsOptions {\n    /** hostname system.host.xy */\n    host: string;\n    /** the received notifications from controller */\n    notifications: NotificationsObject;\n}\n\ninterface FindInstanceOptions {\n    /** id of the scope */\n    scopeId: string;\n    /** id of the category */\n    categoryId: string;\n}\n\ninterface ResponsibleInstances {\n    /** highest priority adapter instance */\n    firstAdapter?: string;\n    /** second priority adapter instance */\n    secondAdapter?: string;\n}\n\nclass NotificationManager extends utils.Adapter {\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'notification-manager',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        this.on('message', this.onMessage.bind(this));\n    }\n\n    /**\n     * Listen to messages from frontend\n     */\n    private async onMessage(obj: ioBroker.Message): Promise<void> {\n        if (obj.command === 'getCategories') {\n            const ioPackPath = require.resolve('iobroker.js-controller/io-package.json');\n\n            const content = await fs.promises.readFile(ioPackPath, {\n                encoding: 'utf-8',\n            });\n\n            const ioPack = JSON.parse(content);\n\n            this.sendTo(obj.from, obj.command, { notifications: ioPack.notifications }, obj.callback);\n            return;\n        }\n\n        if (obj.command === 'getSupportedMessengers') {\n            const res = await this.getObjectViewAsync('system', 'instance', {\n                startkey: 'system.adapter.',\n                endkey: 'system.adapter.\\u9999',\n            });\n\n            const instances = res.rows\n                // @ts-expect-error types are wrong\n                .filter((row) => row.value?.common.type === 'messaging')\n                .map((obj) => obj.id.substring('system.adapter.'.length));\n\n            this.sendTo(obj.from, obj.command, { instances }, obj.callback);\n            return;\n        }\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        this.log.info('Starting notifications manager ...');\n        // TODO: later more generic approach if we have other notifications than system\n        await this.subscribeForeignStates('system.host.*.notifications.system');\n        await this.handleNotifications();\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        callback();\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private onStateChange(_id: string, _state: ioBroker.State | null | undefined): void {\n        // TODO: the notifications object has changed, check if a new notification has been registered\n        // we need to cache the notifications object up from adapter start to check what is new\n        // or we decide to clear the notifications in every case if we handled them, so that\n        // all notifications which we should handle are new or need a new try\n    }\n\n    /**\n     * Checks for existing notifications and handles them accordign to the configuration\n     */\n    private async handleNotifications(): Promise<void> {\n        const hosts = await this.getAllHosts();\n\n        for (const host of hosts) {\n            this.log.debug(`Request notifications from \"${host}\"`);\n\n            const { result: notifications } = (await this.sendToHostAsync(\n                host,\n                'getNotifications',\n                {},\n            )) as unknown as GetNotificationsResponse;\n\n            this.log.debug(`Received notifications from \"${host}\": ${JSON.stringify(notifications)}`);\n\n            await this.sendNotifications({ host, notifications });\n        }\n    }\n\n    /**\n     * Get all existing hosts of this installation\n     */\n    private async getAllHosts(): Promise<string[]> {\n        const res = await this.getObjectViewAsync('system', 'host', {\n            startkey: 'system.host.',\n            endkey: 'system.host.\\u9999',\n        });\n\n        return res.rows.map((host) => host.id);\n    }\n\n    /**\n     * Find the adapter instances configured for the scope and category\n     *\n     * @param options scope and category for the instances\n     */\n    findResponsibleInstances(options: FindInstanceOptions): ResponsibleInstances {\n        const { scopeId, categoryId } = options;\n\n        return {\n            firstAdapter: this.config.categories[scopeId]?.[categoryId]?.firstAdapter,\n            secondAdapter: this.config.categories[scopeId]?.[categoryId]?.secondAdapter,\n        };\n    }\n\n    /**\n     * Sends notifications if configured\n     *\n     * @param options configure hostname and corresponding notifications object\n     */\n    async sendNotifications(options: SendNotificationsOptions): Promise<void> {\n        const { notifications, host } = options;\n\n        for (const [scopeId, scope] of Object.entries(notifications)) {\n            for (const [categoryId, category] of Object.entries(scope.categories)) {\n                const { firstAdapter, secondAdapter } = this.findResponsibleInstances({ scopeId, categoryId });\n\n                for (const adapterInstance of [firstAdapter, secondAdapter]) {\n                    if (!adapterInstance) {\n                        // if first not configured but second, do nothing\n                        return;\n                    }\n\n                    this.log.info(`Send notification \"${scopeId}.${categoryId}\" to \"${adapterInstance}\"`);\n\n                    // TODO: if send to non responding adapter, things hangs forever\n                    const res = await this.sendToAsync(adapterInstance, 'sendNotification', { host, category, scope });\n\n                    if (typeof res?.message === 'object' && res.message.sent) {\n                        this.log.info(\n                            `Instance ${adapterInstance} successfully handled the notification for \"${scopeId}.${categoryId}\"`,\n                        );\n\n                        // TODO: ack the notification\n                        return;\n                    }\n\n                    this.log.error(\n                        `Instance ${adapterInstance} could not handle the notification for \"${scopeId}.${categoryId}\"`,\n                    );\n                }\n            }\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new NotificationManager(options);\n} else {\n    // otherwise start the instance directly\n    (() => new NotificationManager())();\n}\n"],
  "mappings": "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",
  "names": ["fs", "obj"]
}
