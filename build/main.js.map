{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["import * as utils from '@iobroker/adapter-core';\nimport fs from 'node:fs';\n\ninterface GetNotificationsResponse {\n    result: NotificationsObject;\n}\n\ntype HostId = ioBroker.ObjectIDs.Host;\n\ntype Severity = 'alert' | 'info' | 'notify';\n\ninterface NotificationCategory {\n    instances: {\n        [adapterInstance: string]: {\n            messages: NotificationInstanceMessage[];\n        };\n    };\n    /** i18n description of category */\n    description: Record<string, string>;\n    /** i18n name of category */\n    name: Record<string, string>;\n    severity: Severity;\n}\n\n/** Notifications category where i18n objects are already translated */\ninterface LocalizedNotificationCategory extends Omit<NotificationCategory, 'description' | 'name'> {\n    description: string;\n    name: string;\n}\n\ninterface NotificationScope {\n    /** i18n description of scope */\n    description: Record<string, string>;\n    /** i18n name of scope */\n    name: Record<string, string>;\n    categories: {\n        [category: string]: NotificationCategory;\n    };\n}\n\n/** Notifications scope where i18n objects are already translated */\ninterface LocalizedNotificationScope extends Omit<NotificationScope, 'description' | 'name'> {\n    description: string;\n    name: string;\n}\n\ninterface NotificationsObject {\n    [scope: string]: NotificationScope;\n}\n\ninterface NotificationInstanceMessage {\n    message: string;\n    ts: number;\n    contextData?: Record<string, unknown>;\n}\n\ninterface SendNotificationsOptions {\n    /** hostname system.host.xy */\n    host: string;\n    /** the received notifications from controller */\n    notifications: NotificationsObject;\n}\n\ninterface FindInstanceOptions {\n    /** id of the scope */\n    scopeId: string;\n    /** id of the category */\n    categoryId: string;\n    /** Severity of this category */\n    severity: Severity;\n}\n\ninterface CategoryActiveCheckOptions {\n    /** id of the scope */\n    scopeId: string;\n    /** id of the category */\n    categoryId: string;\n}\n\ninterface CacheCheckOptions extends CategoryActiveCheckOptions {\n    /** The notification category */\n    category: NotificationCategory;\n}\n\ninterface ResponsibleInstances {\n    firstAdapter: {\n        /** highest priority adapter instance */\n        main?: string;\n        /** second priority adapter instance */\n        fallback: string;\n    };\n    secondAdapter: {\n        /** Fallback instance for the first instance */\n        main?: string;\n        /** Fallback instance for the second instance */\n        fallback: string;\n    };\n}\n\ninterface LocalizedNotification {\n    /** host where the notification belongs too */\n    host: string;\n    /** The localized scope of the notification */\n    scope: Omit<LocalizedNotificationScope, 'categories'>;\n    /** The localized category of the notification */\n    category: LocalizedNotificationCategory;\n}\n\ninterface CachedEntry {\n    /** Scope of the already sent entry */\n    scopeId: string;\n    /** Category of the already sent entry */\n    categoryId: string;\n    /** Timestamp of the already sent entry */\n    ts: number;\n}\n\nclass NotificationManager extends utils.Adapter {\n    /** Timeout to wait for response by instances on sendTo */\n    private readonly SEND_TO_TIMEOUT = 5_000;\n    /** The supported categories for messages sent by the user */\n    private readonly SUPPORTED_USER_CATEGORIES = ['notify', 'info', 'alert'] as const;\n    /** The scope used for messages sent by the user */\n    private readonly USER_SCOPE = 'user';\n    /** Delete cache of already sent notifications after 30 days */\n    private readonly CACHE_DELETION_TIME = 30 * 86_400_000;\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'notification-manager',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        this.on('message', this.onMessage.bind(this));\n    }\n\n    /**\n     * Listen to messages from frontend\n     *\n     * @param obj the message object\n     */\n    private async onMessage(obj: ioBroker.Message): Promise<void> {\n        switch (obj.command) {\n            case 'getCategories':\n                await this.handleGetCategoriesMessage(obj);\n                break;\n            case 'getSupportedMessengers':\n                await this.handleGetSupportedMessengersMessage(obj);\n                break;\n            case 'sendTestMessage':\n                await this.handleSendTestMessageMessage(obj);\n                break;\n            case 'registerUserNotification':\n                await this.handleRegisterUserNotificationMessage(obj);\n                break;\n            default:\n                this.log.warn(`Unsupported message received \"${obj.command}\"`);\n        }\n    }\n\n    /**\n     * Handle a `registerUserNotification` message, which is used to register a notification by the user itself\n     *\n     * @param obj the ioBroker message\n     */\n    private async handleRegisterUserNotificationMessage(obj: ioBroker.Message): Promise<void> {\n        if (typeof obj.message !== 'object') {\n            return;\n        }\n\n        const { category, message } = obj.message;\n\n        if (!this.SUPPORTED_USER_CATEGORIES.includes(category)) {\n            this.sendTo(\n                obj.from,\n                obj.command,\n                {\n                    success: false,\n                    error: `Unsupported category \"${category}\", please use one of \"${this.SUPPORTED_USER_CATEGORIES.join(\n                        ', ',\n                    )}\"`,\n                },\n                obj.callback,\n            );\n        }\n\n        await this.registerNotification(this.USER_SCOPE, category, message);\n        this.sendTo(obj.from, obj.command, { success: true }, obj.callback);\n    }\n\n    /**\n     * Handle a `sendTestMessage` message used to send a test message by registering a notification\n     *\n     * @param obj the ioBroker message\n     */\n    private async handleSendTestMessageMessage(obj: ioBroker.Message): Promise<void> {\n        if (typeof obj.message !== 'object') {\n            return;\n        }\n\n        const { scopeId, category } = obj.message;\n        this.log.info(`Send test message for scope \"${scopeId}\" and category \"${category}\"`);\n        await this.registerNotification(scopeId, category, 'Test notification from notification-manager');\n        this.sendTo(obj.from, obj.command, { ack: true }, obj.callback);\n    }\n\n    /**\n     * Handle a `getSupportedMessengers` message used to determine all supported messaging adapters\n     *\n     * @param obj the ioBroker message\n     */\n    private async handleGetSupportedMessengersMessage(obj: ioBroker.Message): Promise<void> {\n        const res = await this.getObjectViewAsync('system', 'instance', {\n            startkey: 'system.adapter.',\n            endkey: 'system.adapter.\\u9999',\n        });\n\n        const instances = res.rows\n            .filter(row => row.value?.common.supportedMessages?.notifications)\n            .map(obj => obj.id.substring('system.adapter.'.length));\n\n        this.sendTo(obj.from, obj.command, { instances }, obj.callback);\n    }\n\n    /**\n     * Handle a `getCategories` message used to determine all supported notification categories\n     *\n     * @param obj the ioBroker message\n     */\n    private async handleGetCategoriesMessage(obj: ioBroker.Message): Promise<void> {\n        const ioPackPath = require.resolve('iobroker.js-controller/io-package.json');\n\n        const content = await fs.promises.readFile(ioPackPath, {\n            encoding: 'utf-8',\n        });\n\n        const ioPack = JSON.parse(content);\n        const notifications = ioPack.notifications || [];\n\n        const res = await this.getObjectViewAsync('system', 'adapter', {\n            startkey: 'system.adapter.',\n            endkey: 'system.adapter.\\u9999',\n        });\n\n        for (const entry of res.rows) {\n            if (entry.value.notifications) {\n                notifications.push(...entry.value.notifications);\n            }\n        }\n\n        this.sendTo(obj.from, obj.command, { notifications }, obj.callback);\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        this.log.info('Starting notification manager ...');\n        await this.subscribeForeignStatesAsync('system.host.*.notifications.*');\n        await this.handleNotifications();\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     *\n     * @param callback callback which has to be called after unload handling has finished\n     */\n    private onUnload(callback: () => void): void {\n        callback();\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     *\n     * @param id id of the changed state\n     * @param _state the ioBroker state that has changed\n     */\n    private async onStateChange(id: string, _state: ioBroker.State | null | undefined): Promise<void> {\n        const hostId = this.extractHostFromId(id);\n        this.log.debug(`Notification update on \"${hostId}\" detected`);\n        await this.handleNotifications([hostId]);\n    }\n\n    /**\n     * Extract the hostname from a `system.host.hostPart1.maybeHostPart2.maybeHostPartX.notifications.category` id\n     *\n     * @param id id with structure `system.host.hostPart1.maybeHostPart2.maybeHostPartX.notifications.category`\n     */\n    private extractHostFromId(id: string): HostId {\n        const notificationsId = id.substring(0, id.lastIndexOf('.'));\n        const hostId = id.substring(0, notificationsId.lastIndexOf('.'));\n\n        return hostId as HostId;\n    }\n\n    /**\n     * Checks for existing notifications and handles them according to the configuration\n     *\n     * @param hosts names of the hosts to handle notifications for, if omitted all hosts are used\n     */\n    private async handleNotifications(hosts?: HostId[]): Promise<void> {\n        hosts = hosts || (await this.getAllHosts());\n\n        for (const host of hosts) {\n            this.log.debug(`Request notifications from \"${host}\"`);\n\n            const { result: notifications } = (await this.sendToHostAsync(\n                host,\n                'getNotifications',\n                {},\n            )) as unknown as GetNotificationsResponse;\n\n            this.log.debug(`Received notifications from \"${host}\": ${JSON.stringify(notifications)}`);\n\n            await this.sendNotifications({ host, notifications });\n        }\n    }\n\n    /**\n     * Get all existing hosts of this installation\n     */\n    private async getAllHosts(): Promise<HostId[]> {\n        const res = await this.getObjectViewAsync('system', 'host', {\n            startkey: 'system.host.',\n            endkey: 'system.host.\\u9999',\n        });\n\n        return res.rows.map(host => host.id as HostId);\n    }\n\n    /**\n     * Find the adapter instances configured for the scope and category\n     *\n     * @param options scope and category for the instances\n     */\n    private findResponsibleInstances(options: FindInstanceOptions): ResponsibleInstances {\n        const { scopeId, categoryId, severity } = options;\n\n        return {\n            firstAdapter: {\n                main: this.config.categories[scopeId]?.[categoryId]?.firstAdapter,\n                fallback: this.config.fallback[severity].firstAdapter,\n            },\n            secondAdapter: {\n                main: this.config.categories[scopeId]?.[categoryId]?.secondAdapter,\n                fallback: this.config.fallback[severity].secondAdapter,\n            },\n        };\n    }\n\n    /**\n     * Sends notifications if configured\n     *\n     * @param options configure hostname and corresponding notifications object\n     */\n    private async sendNotifications(options: SendNotificationsOptions): Promise<void> {\n        const { notifications, host } = options;\n\n        for (const [scopeId, scope] of Object.entries(notifications)) {\n            for (const [categoryId, category] of Object.entries(scope.categories)) {\n                const isActive = this.isCategoryActive({ scopeId, categoryId });\n\n                if (!isActive) {\n                    this.log.debug(`Skip notification \"${scopeId}.${categoryId}\" because user opted-out`);\n                    continue;\n                }\n\n                const isSuppressed = this.isCategorySuppressed({ scopeId, categoryId });\n\n                if (isSuppressed) {\n                    this.log.debug(`Suppress notification \"${scopeId}.${categoryId}\"`);\n\n                    await this.sendToHostAsync(host, 'clearNotifications', {\n                        scope: scopeId,\n                        category: categoryId,\n                    });\n\n                    continue;\n                }\n\n                const isCached = await this.isNotificationCached({ scopeId, categoryId, category });\n\n                if (isCached) {\n                    this.log.debug(\n                        `Skip notification for scope \"${scopeId}\" and category \"${categoryId}\", because already sent`,\n                    );\n                    return;\n                }\n\n                const { firstAdapter, secondAdapter } = this.findResponsibleInstances({\n                    scopeId,\n                    categoryId,\n                    severity: category.severity,\n                });\n\n                for (const configuredAdapter of [firstAdapter, secondAdapter]) {\n                    const adapterInstance = configuredAdapter.main || configuredAdapter.fallback;\n                    if (!adapterInstance) {\n                        continue;\n                    }\n\n                    const bareScope: Omit<NotificationScope, 'categories'> = {\n                        name: scope.name,\n                        description: scope.description,\n                    };\n\n                    this.log.info(`Send notification \"${scopeId}.${categoryId}\" to \"${adapterInstance}\"`);\n\n                    const localizedNotification: LocalizedNotification = {\n                        host,\n                        scope: await this.localize(bareScope),\n                        category: await this.localize(category),\n                    };\n\n                    try {\n                        const res = await this.sendToAsync(adapterInstance, 'sendNotification', localizedNotification, {\n                            timeout: this.SEND_TO_TIMEOUT,\n                        });\n\n                        // @ts-expect-error types are wrong, this is a callback not a new message\n                        if (typeof res === 'object' && res.sent) {\n                            this.log.info(\n                                `Instance ${adapterInstance} successfully handled the notification for \"${scopeId}.${categoryId}\"`,\n                            );\n\n                            const deleteWithContextData = this.shouldDeleteWithContextData({ scopeId, categoryId });\n\n                            const hasContextData = this.hasContextData(category);\n\n                            if (!hasContextData || deleteWithContextData) {\n                                await this.sendToHostAsync(host, 'clearNotifications', {\n                                    scope: scopeId,\n                                    category: categoryId,\n                                });\n                                return;\n                            }\n\n                            if (hasContextData) {\n                                await this.cacheNotification({ scopeId, categoryId, category });\n                                await this.updateCache();\n                            }\n\n                            return;\n                        }\n                    } catch (e: any) {\n                        this.log.error(\n                            `Error appeared while sending notification \"${scopeId}.${categoryId}\" to \"${adapterInstance}\": ${e.message}`,\n                        );\n                    }\n\n                    this.log.error(\n                        `Instance ${adapterInstance} could not handle the notification for \"${scopeId}.${categoryId}\"`,\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Add the given notification to the cache\n     *\n     * @param options category and scope information\n     */\n    private async cacheNotification(options: CacheCheckOptions): Promise<void> {\n        const { scopeId, categoryId, category } = options;\n\n        // take the ts any message\n        const ts = Object.values(category.instances)[0].messages[0].ts;\n\n        const cacheState = (await this.getStateAsync('cache'))?.val;\n        let cache: CachedEntry[] = [];\n\n        if (typeof cacheState === 'string') {\n            cache = JSON.parse(cacheState);\n        }\n\n        cache.push({ scopeId, categoryId, ts });\n\n        await this.setState('cache', JSON.stringify(cache), true);\n    }\n\n    /**\n     * Clear old data from cache to prevent growing too large\n     * This has the side effect that every `CACHE_DELETION_TIME` the message can be sent again if user hasn't interacted with it until then\n     */\n    private async updateCache(): Promise<void> {\n        const cacheState = (await this.getStateAsync('cache'))?.val;\n        let cache: CachedEntry[] = [];\n\n        if (typeof cacheState === 'string') {\n            cache = JSON.parse(cacheState);\n        }\n\n        cache = cache.filter(cachedEntry => cachedEntry.ts > Date.now() - this.CACHE_DELETION_TIME);\n        await this.setState('cache', JSON.stringify(cache), true);\n    }\n\n    /**\n     * Check if given notification is cached\n     *\n     * @param options scope and category information\n     */\n    private async isNotificationCached(options: CacheCheckOptions): Promise<boolean> {\n        const { scopeId, category, categoryId } = options;\n\n        const cacheState = (await this.getStateAsync('cache'))?.val;\n        let cache: CachedEntry[] = [];\n\n        if (typeof cacheState === 'string') {\n            cache = JSON.parse(cacheState);\n        }\n\n        for (const cachedEntry of cache) {\n            if (cachedEntry.scopeId !== scopeId || cachedEntry.categoryId !== categoryId) {\n                continue;\n            }\n\n            const alreadySent = Object.values(category.instances).some(instance =>\n                instance.messages.some(message => message.ts === cachedEntry.ts),\n            );\n\n            if (alreadySent) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if the category is active or opted out by the user\n     *\n     * @param options scope and category information\n     */\n    private isCategoryActive(options: CategoryActiveCheckOptions): boolean {\n        const { scopeId, categoryId } = options;\n        return this.config.categories[scopeId]?.[categoryId]?.active !== false;\n    }\n\n    /**\n     * Check if category has contextData\n     *\n     * @param category the category to check for contextData\n     */\n    private hasContextData(category: NotificationCategory): boolean {\n        return Object.values(category.instances).some(instance =>\n            instance.messages.some(message => !!message.contextData),\n        );\n    }\n\n    /**\n     * Check if the category is suppressed and should be cleared\n     *\n     * @param options scope and category information\n     */\n    private isCategorySuppressed(options: CategoryActiveCheckOptions): boolean {\n        const { scopeId, categoryId } = options;\n        return !!this.config.categories[scopeId]?.[categoryId]?.suppress;\n    }\n\n    /**\n     * Check if we should clear notification for this category also if it has contextData present\n     *\n     * @param options scope and category information\n     */\n    private shouldDeleteWithContextData(options: CategoryActiveCheckOptions): boolean {\n        const { scopeId, categoryId } = options;\n\n        return !!this.config.categories[scopeId]?.[categoryId]?.deleteWithContextData;\n    }\n\n    /**\n     * Transform scope or category to the localized version\n     *\n     * @param scopeOrCategory a notifications scope or category\n     */\n    private async localize<T extends Omit<NotificationScope, 'categories'> | NotificationCategory>(\n        scopeOrCategory: T,\n    ): Promise<T & { name: string; description: string }> {\n        const config = await this.getForeignObjectAsync('system.config');\n\n        const lang = config?.common.language || 'en';\n\n        const description = scopeOrCategory.description[lang];\n        const name = scopeOrCategory.name[lang];\n\n        return { ...scopeOrCategory, description, name };\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new NotificationManager(options);\n} else {\n    // otherwise start the instance directly\n    (() => new NotificationManager())();\n}\n"],
  "mappings": "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",
  "names": ["obj", "fs"]
}
