{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["import * as utils from '@iobroker/adapter-core';\nimport fs from 'fs';\n\ninterface GetNotificationsResponse {\n    result: NotificationsObject;\n}\n\ntype HostId = `system.host.${string}`;\n\ntype Severity = 'alert' | 'info' | 'notify';\n\ninterface NotificationCategory {\n    instances: {\n        [adapterInstance: string]: {\n            messages: NotificationInstanceMessage[];\n        };\n    };\n    /** i18n description of category */\n    description: Record<string, string>;\n    /** i18n name of category */\n    name: Record<string, string>;\n    severity: Severity;\n}\n\n/** Notifications category where i18n objects are already translated */\ninterface LocalizedNotificationCategory extends Omit<NotificationCategory, 'description' | 'name'> {\n    description: string;\n    name: string;\n}\n\ninterface NotificationScope {\n    /** i18n description of scope */\n    description: Record<string, string>;\n    /** i18n name of scope */\n    name: Record<string, string>;\n    categories: {\n        [category: string]: NotificationCategory;\n    };\n}\n\n/** Notifications scope where i18n objects are already translated */\ninterface LocalizedNotificationScope extends Omit<NotificationScope, 'description' | 'name'> {\n    description: string;\n    name: string;\n}\n\ninterface NotificationsObject {\n    [scope: string]: NotificationScope;\n}\n\ninterface NotificationInstanceMessage {\n    message: string;\n    ts: number;\n}\n\ninterface SendNotificationsOptions {\n    /** hostname system.host.xy */\n    host: string;\n    /** the received notifications from controller */\n    notifications: NotificationsObject;\n}\n\ninterface FindInstanceOptions {\n    /** id of the scope */\n    scopeId: string;\n    /** id of the category */\n    categoryId: string;\n    /** Severity of this category */\n    severity: Severity;\n}\n\ninterface CategoryActiveCheckOptions {\n    /** id of the scope */\n    scopeId: string;\n    /** id of the category */\n    categoryId: string;\n}\n\ninterface ResponsibleInstances {\n    firstAdapter: {\n        /** highest priority adapter instance */\n        main?: string;\n        /** second priority adapter instance */\n        fallback: string;\n    };\n    secondAdapter: {\n        /** Fallback instance for the first instance */\n        main?: string;\n        /** Fallback instance for the second instance */\n        fallback: string;\n    };\n}\n\ninterface LocalizedNotification {\n    /** host where the notification belongs too */\n    host: string;\n    /** The localized scope of the notification */\n    scope: Omit<LocalizedNotificationScope, 'categories'>;\n    /** The localized category of the notification */\n    category: LocalizedNotificationCategory;\n}\n\nclass NotificationManager extends utils.Adapter {\n    /** Timeout to wait for response by instances on sendTo */\n    private readonly SEND_TO_TIMEOUT = 5_000;\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'notification-manager',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        this.on('message', this.onMessage.bind(this));\n    }\n\n    /**\n     * Listen to messages from frontend\n     */\n    private async onMessage(obj: ioBroker.Message): Promise<void> {\n        if (obj.command === 'getCategories') {\n            const ioPackPath = require.resolve('iobroker.js-controller/io-package.json');\n\n            const content = await fs.promises.readFile(ioPackPath, {\n                encoding: 'utf-8',\n            });\n\n            const ioPack = JSON.parse(content);\n            const notifications = ioPack.notifications || [];\n\n            const res = await this.getObjectViewAsync('system', 'adapter', {\n                startkey: 'system.adapter.',\n                endkey: 'system.adapter.\\u9999',\n            });\n\n            for (const entry of res.rows) {\n                if (entry.value.notifications) {\n                    notifications.push(...entry.value.notifications);\n                }\n            }\n\n            this.sendTo(obj.from, obj.command, { notifications: notifications }, obj.callback);\n            return;\n        }\n\n        if (obj.command === 'getSupportedMessengers') {\n            const res = await this.getObjectViewAsync('system', 'instance', {\n                startkey: 'system.adapter.',\n                endkey: 'system.adapter.\\u9999',\n            });\n\n            const instances = res.rows\n                .filter((row) => row.value?.common.supportedMessages?.notifications)\n                .map((obj) => obj.id.substring('system.adapter.'.length));\n\n            this.sendTo(obj.from, obj.command, { instances }, obj.callback);\n            return;\n        }\n\n        if (obj.command === 'sendTestMessage') {\n            if (typeof obj.message !== 'object') {\n                return;\n            }\n\n            const { scopeId, category } = obj.message;\n            this.log.info(`Send test message for scope \"${scopeId}\" and category \"${category}\"`);\n            await this.registerNotification(scopeId, category, 'Test notification from notification-manager');\n            this.sendTo(obj.from, obj.command, { ack: true }, obj.callback);\n            return;\n        }\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        this.log.info('Starting notification manager ...');\n        await this.subscribeForeignStates('system.host.*.notifications.*');\n        await this.handleNotifications();\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        callback();\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private async onStateChange(id: string, _state: ioBroker.State | null | undefined): Promise<void> {\n        const hostName = id.split('.')[2];\n        this.log.info(`New notification on \"${hostName}\" detected`);\n        await this.handleNotifications([`system.host.${hostName}`]);\n    }\n\n    /**\n     * Checks for existing notifications and handles them according to the configuration\n     *\n     * @param hosts names of the hosts to handle notifications for, if omitted all hosts are used\n     */\n    private async handleNotifications(hosts?: HostId[]): Promise<void> {\n        hosts = hosts || (await this.getAllHosts());\n\n        for (const host of hosts) {\n            this.log.debug(`Request notifications from \"${host}\"`);\n\n            const { result: notifications } = (await this.sendToHostAsync(\n                host,\n                'getNotifications',\n                {},\n            )) as unknown as GetNotificationsResponse;\n\n            this.log.debug(`Received notifications from \"${host}\": ${JSON.stringify(notifications)}`);\n\n            await this.sendNotifications({ host, notifications });\n        }\n    }\n\n    /**\n     * Get all existing hosts of this installation\n     */\n    private async getAllHosts(): Promise<HostId[]> {\n        const res = await this.getObjectViewAsync('system', 'host', {\n            startkey: 'system.host.',\n            endkey: 'system.host.\\u9999',\n        });\n\n        return res.rows.map((host) => host.id as HostId);\n    }\n\n    /**\n     * Find the adapter instances configured for the scope and category\n     *\n     * @param options scope and category for the instances\n     */\n    private findResponsibleInstances(options: FindInstanceOptions): ResponsibleInstances {\n        const { scopeId, categoryId, severity } = options;\n\n        return {\n            firstAdapter: {\n                main: this.config.categories[scopeId]?.[categoryId]?.firstAdapter,\n                fallback: this.config.fallback[severity].firstAdapter,\n            },\n            secondAdapter: {\n                main: this.config.categories[scopeId]?.[categoryId]?.secondAdapter,\n                fallback: this.config.fallback[severity].secondAdapter,\n            },\n        };\n    }\n\n    /**\n     * Sends notifications if configured\n     *\n     * @param options configure hostname and corresponding notifications object\n     */\n    private async sendNotifications(options: SendNotificationsOptions): Promise<void> {\n        const { notifications, host } = options;\n\n        for (const [scopeId, scope] of Object.entries(notifications)) {\n            for (const [categoryId, category] of Object.entries(scope.categories)) {\n                const isActive = this.isCategoryActive({ scopeId, categoryId });\n\n                if (!isActive) {\n                    this.log.debug(`Skip notification \"${scopeId}.${categoryId}\" because user opted-out`);\n                    continue;\n                }\n\n                const { firstAdapter, secondAdapter } = this.findResponsibleInstances({\n                    scopeId,\n                    categoryId,\n                    severity: category.severity,\n                });\n\n                for (const configuredAdapter of [firstAdapter, secondAdapter]) {\n                    const adapterInstance = configuredAdapter.main || configuredAdapter.fallback;\n                    if (!adapterInstance) {\n                        // if first not configured but second, do nothing\n                        return;\n                    }\n\n                    const bareScope: Omit<NotificationScope, 'categories'> = {\n                        name: scope.name,\n                        description: scope.description,\n                    };\n\n                    this.log.info(`Send notification \"${scopeId}.${categoryId}\" to \"${adapterInstance}\"`);\n\n                    const localizedNotification: LocalizedNotification = {\n                        host,\n                        scope: await this.localize(bareScope),\n                        category: await this.localize(category),\n                    };\n\n                    try {\n                        const res = await this.sendToAsync(adapterInstance, 'sendNotification', localizedNotification, {\n                            timeout: this.SEND_TO_TIMEOUT,\n                        });\n\n                        // @ts-expect-error types are wrong, this is a callback not a new message\n                        if (typeof res === 'object' && res.sent) {\n                            this.log.info(\n                                `Instance ${adapterInstance} successfully handled the notification for \"${scopeId}.${categoryId}\"`,\n                            );\n\n                            await this.sendToHostAsync(host, 'clearNotifications', {\n                                scopeFilter: scopeId,\n                                categoryFilter: categoryId,\n                            });\n                            return;\n                        }\n                    } catch (e: any) {\n                        this.log.error(\n                            `Error appeared while sending notification \"${scopeId}.${categoryId}\" to \"${adapterInstance}\": ${e.message}`,\n                        );\n                    }\n\n                    this.log.error(\n                        `Instance ${adapterInstance} could not handle the notification for \"${scopeId}.${categoryId}\"`,\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if the category is active or opted out by the user\n     *\n     * @param options scope and category information\n     */\n    private isCategoryActive(options: CategoryActiveCheckOptions): boolean {\n        const { scopeId, categoryId } = options;\n        return this.config.categories[scopeId]?.[categoryId]?.active !== false;\n    }\n\n    /**\n     * Transform scope or category to the localized version\n     *\n     * @param scopeOrCategory a notifications scope or category\n     */\n    private async localize<T extends Omit<NotificationScope, 'categories'> | NotificationCategory>(\n        scopeOrCategory: T,\n    ): Promise<T & { name: string; description: string }> {\n        const config = await this.getForeignObjectAsync('system.config');\n\n        const lang = config?.common.language || 'en';\n\n        const description = scopeOrCategory.description[lang];\n        const name = scopeOrCategory.name[lang];\n\n        return { ...scopeOrCategory, description, name };\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new NotificationManager(options);\n} else {\n    // otherwise start the instance directly\n    (() => new NotificationManager())();\n}\n"],
  "mappings": "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",
  "names": ["fs", "obj"]
}
