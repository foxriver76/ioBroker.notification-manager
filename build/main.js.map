{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["import * as utils from '@iobroker/adapter-core';\nimport fs from 'fs';\n\ninterface GetNotificationsResponse {\n    result: NotificationsObject;\n}\n\ntype HostId = `system.host.${string}`;\n\ntype Severity = 'alert' | 'info' | 'notify';\n\ninterface NotificationCategory {\n    instances: {\n        [adapterInstance: string]: {\n            messages: NotificationInstanceMessage[];\n        };\n    };\n    /** i18n description of category */\n    description: Record<string, string>;\n    /** i18n name of category */\n    name: Record<string, string>;\n    severity: Severity;\n}\n\n/** Notifications category where i18n objects are already translated */\ninterface LocalizedNotificationCategory extends Omit<NotificationCategory, 'description' | 'name'> {\n    description: string;\n    name: string;\n}\n\ninterface NotificationScope {\n    /** i18n description of scope */\n    description: Record<string, string>;\n    /** i18n name of scope */\n    name: Record<string, string>;\n    categories: {\n        [category: string]: NotificationCategory;\n    };\n}\n\n/** Notifications scope where i18n objects are already translated */\ninterface LocalizedNotificationScope extends Omit<NotificationScope, 'description' | 'name'> {\n    description: string;\n    name: string;\n}\n\ninterface NotificationsObject {\n    [scope: string]: NotificationScope;\n}\n\ninterface NotificationInstanceMessage {\n    message: string;\n    ts: number;\n}\n\ninterface SendNotificationsOptions {\n    /** hostname system.host.xy */\n    host: string;\n    /** the received notifications from controller */\n    notifications: NotificationsObject;\n}\n\ninterface FindInstanceOptions {\n    /** id of the scope */\n    scopeId: string;\n    /** id of the category */\n    categoryId: string;\n    /** Severity of this category */\n    severity: Severity;\n}\n\ninterface CategoryActiveCheckOptions {\n    /** id of the scope */\n    scopeId: string;\n    /** id of the category */\n    categoryId: string;\n}\n\ninterface ResponsibleInstances {\n    firstAdapter: {\n        /** highest priority adapter instance */\n        main?: string;\n        /** second priority adapter instance */\n        fallback: string;\n    };\n    secondAdapter: {\n        /** Fallback instance for the first instance */\n        main?: string;\n        /** Fallback instance for the second instance */\n        fallback: string;\n    };\n}\n\ninterface LocalizedNotification {\n    /** host where the notification belongs too */\n    host: string;\n    /** The localized scope of the notification */\n    scope: Omit<LocalizedNotificationScope, 'categories'>;\n    /** The localized category of the notification */\n    category: LocalizedNotificationCategory;\n}\n\nclass NotificationManager extends utils.Adapter {\n    /** Timeout to wait for response by instances on sendTo */\n    private readonly SEND_TO_TIMEOUT = 5_000;\n    /** The supported categories for messages sent by the user */\n    private readonly SUPPORTED_USER_CATEGORIES = ['notify', 'info', 'alert'] as const;\n    /** The scope used for messages sent by the user */\n    private readonly USER_SCOPE = 'user';\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'notification-manager'\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        this.on('message', this.onMessage.bind(this));\n    }\n\n    /**\n     * Listen to messages from frontend\n     */\n    private async onMessage(obj: ioBroker.Message): Promise<void> {\n        switch (obj.command) {\n            case 'getCategories':\n                await this.handleGetCategoriesMessage(obj);\n                break;\n            case 'getSupportedMessengers':\n                await this.handleGetSupportedMessengersMessage(obj);\n                break;\n            case 'sendTestMessage':\n                await this.handleSendTestMessageMessage(obj);\n                break;\n            case 'registerUserNotification':\n                await this.handleRegisterUserNotificationMessage(obj);\n                break;\n            default:\n                this.log.warn(`Unsupported message received \"${obj.command}\"`);\n        }\n    }\n\n    /**\n     * Handle a `registerUserNotification` message, which is used to register a notification by the user itself\n     *\n     * @param obj the ioBroker message\n     */\n    private async handleRegisterUserNotificationMessage(obj: ioBroker.Message): Promise<void> {\n        if (typeof obj.message !== 'object') {\n            return;\n        }\n\n        const { category, message } = obj.message;\n\n        if (!this.SUPPORTED_USER_CATEGORIES.includes(category)) {\n            this.sendTo(\n                obj.from,\n                obj.command,\n                {\n                    success: false,\n                    error: `Unsupported category \"${category}\", please use one of \"${this.SUPPORTED_USER_CATEGORIES.join(\n                        ', '\n                    )}\"`\n                },\n                obj.callback\n            );\n        }\n\n        // @ts-expect-error js-controller types are restricted to \"system\" here, should be fixed soon\n        await this.registerNotification(this.USER_SCOPE, category, message);\n        this.sendTo(obj.from, obj.command, { success: true }, obj.callback);\n    }\n\n    /**\n     * Handle a `sendTestMessage` message used to send a test message by registering a notification\n     *\n     * @param obj the ioBroker message\n     */\n    private async handleSendTestMessageMessage(obj: ioBroker.Message): Promise<void> {\n        if (typeof obj.message !== 'object') {\n            return;\n        }\n\n        const { scopeId, category } = obj.message;\n        this.log.info(`Send test message for scope \"${scopeId}\" and category \"${category}\"`);\n        await this.registerNotification(scopeId, category, 'Test notification from notification-manager');\n        this.sendTo(obj.from, obj.command, { ack: true }, obj.callback);\n    }\n\n    /**\n     * Handle a `getSupportedMessengers` message used to determine all supported messaging adapters\n     *\n     * @param obj the ioBroker message\n     */\n    private async handleGetSupportedMessengersMessage(obj: ioBroker.Message): Promise<void> {\n        const res = await this.getObjectViewAsync('system', 'instance', {\n            startkey: 'system.adapter.',\n            endkey: 'system.adapter.\\u9999'\n        });\n\n        const instances = res.rows\n            .filter(row => row.value?.common.supportedMessages?.notifications)\n            .map(obj => obj.id.substring('system.adapter.'.length));\n\n        this.sendTo(obj.from, obj.command, { instances }, obj.callback);\n    }\n\n    /**\n     * Handle a `getCategories` message used to determine all supported notification categories\n     *\n     * @param obj the ioBroker message\n     */\n    private async handleGetCategoriesMessage(obj: ioBroker.Message): Promise<void> {\n        const ioPackPath = require.resolve('iobroker.js-controller/io-package.json');\n\n        const content = await fs.promises.readFile(ioPackPath, {\n            encoding: 'utf-8'\n        });\n\n        const ioPack = JSON.parse(content);\n        const notifications = ioPack.notifications || [];\n\n        const res = await this.getObjectViewAsync('system', 'adapter', {\n            startkey: 'system.adapter.',\n            endkey: 'system.adapter.\\u9999'\n        });\n\n        for (const entry of res.rows) {\n            if (entry.value.notifications) {\n                notifications.push(...entry.value.notifications);\n            }\n        }\n\n        this.sendTo(obj.from, obj.command, { notifications }, obj.callback);\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        this.log.info('Starting notification manager ...');\n        await this.subscribeForeignStatesAsync('system.host.*.notifications.*');\n        await this.handleNotifications();\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        callback();\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private async onStateChange(id: string, _state: ioBroker.State | null | undefined): Promise<void> {\n        const hostName = id.split('.')[2];\n        this.log.debug(`Notification update on \"${hostName}\" detected`);\n        await this.handleNotifications([`system.host.${hostName}`]);\n    }\n\n    /**\n     * Checks for existing notifications and handles them according to the configuration\n     *\n     * @param hosts names of the hosts to handle notifications for, if omitted all hosts are used\n     */\n    private async handleNotifications(hosts?: HostId[]): Promise<void> {\n        hosts = hosts || (await this.getAllHosts());\n\n        for (const host of hosts) {\n            this.log.debug(`Request notifications from \"${host}\"`);\n\n            const { result: notifications } = (await this.sendToHostAsync(\n                host,\n                'getNotifications',\n                {}\n            )) as unknown as GetNotificationsResponse;\n\n            this.log.debug(`Received notifications from \"${host}\": ${JSON.stringify(notifications)}`);\n\n            await this.sendNotifications({ host, notifications });\n        }\n    }\n\n    /**\n     * Get all existing hosts of this installation\n     */\n    private async getAllHosts(): Promise<HostId[]> {\n        const res = await this.getObjectViewAsync('system', 'host', {\n            startkey: 'system.host.',\n            endkey: 'system.host.\\u9999'\n        });\n\n        return res.rows.map(host => host.id as HostId);\n    }\n\n    /**\n     * Find the adapter instances configured for the scope and category\n     *\n     * @param options scope and category for the instances\n     */\n    private findResponsibleInstances(options: FindInstanceOptions): ResponsibleInstances {\n        const { scopeId, categoryId, severity } = options;\n\n        return {\n            firstAdapter: {\n                main: this.config.categories[scopeId]?.[categoryId]?.firstAdapter,\n                fallback: this.config.fallback[severity].firstAdapter\n            },\n            secondAdapter: {\n                main: this.config.categories[scopeId]?.[categoryId]?.secondAdapter,\n                fallback: this.config.fallback[severity].secondAdapter\n            }\n        };\n    }\n\n    /**\n     * Sends notifications if configured\n     *\n     * @param options configure hostname and corresponding notifications object\n     */\n    private async sendNotifications(options: SendNotificationsOptions): Promise<void> {\n        const { notifications, host } = options;\n\n        for (const [scopeId, scope] of Object.entries(notifications)) {\n            for (const [categoryId, category] of Object.entries(scope.categories)) {\n                const isActive = this.isCategoryActive({ scopeId, categoryId });\n\n                if (!isActive) {\n                    this.log.debug(`Skip notification \"${scopeId}.${categoryId}\" because user opted-out`);\n                    continue;\n                }\n\n                const isSuppressed = this.isCategorySuppressed({ scopeId, categoryId });\n\n                if (isSuppressed) {\n                    this.log.debug(`Suppress notification \"${scopeId}.${categoryId}\"`);\n\n                    await this.sendToHostAsync(host, 'clearNotifications', {\n                        scope: scopeId,\n                        category: categoryId\n                    });\n\n                    continue;\n                }\n\n                const { firstAdapter, secondAdapter } = this.findResponsibleInstances({\n                    scopeId,\n                    categoryId,\n                    severity: category.severity\n                });\n\n                for (const configuredAdapter of [firstAdapter, secondAdapter]) {\n                    const adapterInstance = configuredAdapter.main || configuredAdapter.fallback;\n                    if (!adapterInstance) {\n                        continue;\n                    }\n\n                    const bareScope: Omit<NotificationScope, 'categories'> = {\n                        name: scope.name,\n                        description: scope.description\n                    };\n\n                    this.log.info(`Send notification \"${scopeId}.${categoryId}\" to \"${adapterInstance}\"`);\n\n                    const localizedNotification: LocalizedNotification = {\n                        host,\n                        scope: await this.localize(bareScope),\n                        category: await this.localize(category)\n                    };\n\n                    try {\n                        const res = await this.sendToAsync(adapterInstance, 'sendNotification', localizedNotification, {\n                            timeout: this.SEND_TO_TIMEOUT\n                        });\n\n                        // @ts-expect-error types are wrong, this is a callback not a new message\n                        if (typeof res === 'object' && res.sent) {\n                            this.log.info(\n                                `Instance ${adapterInstance} successfully handled the notification for \"${scopeId}.${categoryId}\"`\n                            );\n\n                            await this.sendToHostAsync(host, 'clearNotifications', {\n                                scope: scopeId,\n                                category: categoryId\n                            });\n                            return;\n                        }\n                    } catch (e: any) {\n                        this.log.error(\n                            `Error appeared while sending notification \"${scopeId}.${categoryId}\" to \"${adapterInstance}\": ${e.message}`\n                        );\n                    }\n\n                    this.log.error(\n                        `Instance ${adapterInstance} could not handle the notification for \"${scopeId}.${categoryId}\"`\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if the category is active or opted out by the user\n     *\n     * @param options scope and category information\n     */\n    private isCategoryActive(options: CategoryActiveCheckOptions): boolean {\n        const { scopeId, categoryId } = options;\n        return this.config.categories[scopeId]?.[categoryId]?.active !== false;\n    }\n\n    /**\n     * Check if the category is suppressed and should be cleared\n     *\n     * @param options scope and category information\n     */\n    private isCategorySuppressed(options: CategoryActiveCheckOptions): boolean {\n        const { scopeId, categoryId } = options;\n        return !!this.config.categories[scopeId]?.[categoryId]?.suppress;\n    }\n\n    /**\n     * Transform scope or category to the localized version\n     *\n     * @param scopeOrCategory a notifications scope or category\n     */\n    private async localize<T extends Omit<NotificationScope, 'categories'> | NotificationCategory>(\n        scopeOrCategory: T\n    ): Promise<T & { name: string; description: string }> {\n        const config = await this.getForeignObjectAsync('system.config');\n\n        const lang = config?.common.language || 'en';\n\n        const description = scopeOrCategory.description[lang];\n        const name = scopeOrCategory.name[lang];\n\n        return { ...scopeOrCategory, description, name };\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new NotificationManager(options);\n} else {\n    // otherwise start the instance directly\n    (() => new NotificationManager())();\n}\n"],
  "mappings": "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",
  "names": ["obj", "fs"]
}
